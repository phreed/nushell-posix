[[converter-architecture]]
= Converter Architecture

== Overview

The converter architecture forms the core of the nu-posix system, responsible for transforming parsed POSIX shell constructs into equivalent Nushell syntax. This chapter details the design principles, implementation patterns, and extensibility mechanisms that make the conversion system both robust and flexible.

== Architecture Principles

=== Hierarchical Conversion

The converter system employs a hierarchical approach to command conversion:

1. **Builtin Registry**: Handles POSIX shell built-in commands
2. **SUS Registry**: Manages Single Unix Specification utilities
3. **External Fallback**: Provides generic handling for unregistered commands

This hierarchy ensures that specialized converters take precedence over generic ones, while maintaining comprehensive coverage.

=== Trait-Based Design

All converters implement standardized traits that define consistent interfaces:

```rust
pub trait CommandConverter {
    fn convert(&self, args: &[String]) -> Result<String>;
    fn command_name(&self) -> &'static str;
    fn description(&self) -> &'static str;
}
```

=== Extensibility

The architecture supports easy addition of new converters through:

* **Registry Registration**: Simple converter registration mechanism
* **Plugin System**: Future support for third-party converters
* **Modular Design**: Independent converter development and testing

== Core Components

=== PosixToNuConverter

The main converter coordinates the transformation process:

```rust
pub struct PosixToNuConverter {
    builtin_registry: BuiltinRegistry,
    sus_registry: CommandRegistry,
}
```

=== Base Converter

Provides common functionality for all converters:

```rust
pub struct BaseConverter;

impl BaseConverter {
    pub fn quote_arg(&self, arg: &str) -> String {
        // Handles argument quoting logic
    }

    pub fn format_args(&self, args: &[String]) -> String {
        // Formats argument lists
    }
}
```

== Conversion Strategies

=== Direct Translation

Simple one-to-one command mappings:

* `echo` → `print`
* `pwd` → `pwd`
* `cd` → `cd`

=== Functional Transformation

Complex operations transformed to functional style:

* `grep pattern file` → `open file | lines | where $it =~ pattern`
* `head -n 10 file` → `open file | lines | first 10`

=== External Command Delegation

Complex tools handled as external commands:

* `awk` → `^awk` (with proper argument handling)
* `sed` → Mixed approach based on complexity

== Registry System

=== Command Registration

Converters are registered in priority-ordered registries:

```rust
impl CommandRegistry {
    pub fn new() -> Self {
        let mut registry = Self::default();
        registry.register(Box::new(LsConverter));
        registry.register(Box::new(GrepConverter));
        registry.register(Box::new(AwkConverter));
        // ... other converters
        registry
    }
}
```

=== Lookup Process

Command resolution follows a specific order:

1. Search builtin registry
2. Search SUS registry
3. Fall back to external command handling

== Error Handling

=== Graceful Degradation

The system handles failures gracefully:

* Parser errors fall back to heuristic parsing
* Conversion errors fall back to external command execution
* Registry misses are handled as external commands

=== Error Propagation

Clear error messages with context:

```rust
#[derive(Debug, thiserror::Error)]
pub enum ConversionError {
    #[error("Parse error: {0}")]
    ParseError(String),
    #[error("Conversion error: {0}")]
    ConversionError(String),
    #[error("Registry error: {0}")]
    RegistryError(String),
}
```

== Testing Strategy

=== Unit Testing

Each converter is thoroughly tested:

```rust
#[test]
fn test_converter_basic() {
    let converter = SomeConverter;
    let result = converter.convert(&["arg1".to_string()]).unwrap();
    assert_eq!(result, "expected_output");
}
```

=== Integration Testing

Complete conversion pipeline testing validates the architecture.

== Performance Considerations

=== Caching

* **Registry Caching**: Converter lookups are cached
* **Result Caching**: Conversion results can be cached
* **Lazy Loading**: Converters loaded on demand

=== Memory Management

* **Minimal Allocations**: Efficient string handling
* **Resource Cleanup**: Proper cleanup of temporary resources
* **Streaming Support**: Large file processing optimization

== Future Enhancements

=== Plugin System

Support for third-party converters:

* **Dynamic Loading**: Runtime converter registration
* **API Standardization**: Consistent plugin interfaces
* **Security Model**: Safe plugin execution

=== Advanced Features

* **Context-Aware Conversion**: Conversion based on usage context
* **Optimization Passes**: Multi-pass conversion optimization
* **Custom Dialects**: Support for shell-specific features

== Conclusion

The converter architecture provides a solid foundation for POSIX to Nushell conversion. Its hierarchical design, trait-based interfaces, and comprehensive error handling ensure both reliability and extensibility. The architecture's modular nature enables independent development and testing of individual converters while maintaining system coherence.

This design successfully balances the need for specialized conversion logic with the requirement for consistent, maintainable code. The result is a conversion system that can handle both simple and complex POSIX shell constructs while providing clear extension points for future enhancements.
