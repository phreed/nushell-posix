= Mapping POSIX AST (yash-syntax) to Nu AST (nushell)

This document explores the conceptual challenges and strategies for creating a mapping between the Abstract Syntax Tree (AST) of a POSIX-compliant shell (specifically, as derived from yash-syntax) and the AST of Nushell.

== Understanding Abstract Syntax Trees (ASTs)
An AST is a tree representation of the abstract syntactic structure of source code written in a programming language.
Each node in the tree denotes a construct occurring in the source code.
The structure of an AST is crucial because it captures the hierarchical relationships and logical flow of the code, making it suitable for analysis, transformation, and compilation.

Mapping two different ASTs involves translating the constructs and relationships from one language's syntax tree into another's.
This is particularly challenging when the underlying paradigms of the languages differ significantly, as is the case with traditional POSIX shells and Nushell.

== POSIX AST (yash-syntax) OverviewA POSIX shell's AST, like one generated by yash-syntax, reflects the traditional Unix philosophy of "everything is a string" and "pipes connect streams of text."

Key constructs typically found in a POSIX AST include:Command: A simple command consists of a command name and its arguments.

=== Pipeline: A sequence of one or more commands connected by pipes (|).

The output of one command becomes the input of the next.

=== Redirection: Changing the input/output streams of a command (e.g., command > file, command < file, command 2>&1).

=== List/Sequence: A series of commands executed sequentially, often separated by ; or & (for background execution).

=== Conditional Statements: if-then-else-fi blocks.

=== Looping Constructs: for, while, ``until` loops.

=== Function Definitions: Defining shell functions.

=== Variable Assignments: VAR=value.

=== Subshells: Commands executed in a new shell environment (commands).

=== Command Substitution: $(command) or `command`.

=== Arithmetic Expansion: $((expression)).

=== Parameter Expansion: ${VAR}, ${VAR:-default}, etc.

=== Logical Operators: && (AND), || (OR) for conditional execution.

The yash-syntax library would provide specific node types for each of these constructs, along with their properties (e.g., CommandNode with name and arguments children, PipelineNode with a list of CommandNode children).

== Nu AST (nushell) Overview

Nushell's AST reflects its core philosophy of "everything is structured data."
While it supports traditional shell-like operations,
its internal representation emphasizes typed values, tables, and blocks.
Key constructs in a Nu AST include:

=== Command: Similar to POSIX, but arguments can be structured (e.g., flags, named arguments).

=== Pipeline: A sequence of commands, but the output of one command is structured data (e.g., a table, a list, a record) that becomes the structured input of the next.

=== Block: A collection of statements or expressions, often used in control flow, custom commands, or closures.

=== Expression: Any construct that evaluates to a value (e.g., literals, variable access, function calls, arithmetic operations).

=== Literal: Primitive values like numbers, strings, booleans, lists, records, paths.

=== Variable Definition/Assignment: let var = value, mut var = value.

=== Control Flow: if-else, for loops, loop, match.

=== Custom Command Definition: def command_name [params] { body }.

=== Table/Record Literals: Direct representation of structured data.

=== Closures: Anonymous blocks of code.

=== Redirection (Implicit/Explicit): While Nu has > file, >> file, | save file, its primary data flow is through structured pipelines.

The Nu AST would have node types reflecting these concepts, such as Call (for commands), Pipeline, Block, List, Record, If, For, Let, Def, etc.

== Mapping Challenges
The primary challenges in mapping POSIX to Nu AST arise from their fundamental differences:

=== Data Paradigm:

POSIX:: Text-stream-oriented.
All data is essentially a string, and parsing happens at each command.
Nu:: Structured-data-oriented.
Data flows as typed values (tables, lists, records, primitives) through the pipeline.
Challenge:: How to translate POSIX's string-based input/output into Nu's structured data, and vice-versa (though the request is POSIX to Nu).
This often requires explicit parsing or interpretation in Nu.

=== Implicit vs. Explicit Structure:

POSIX:: Structure is often implicit (e.g., whitespace separation for arguments).
Nu:: Structure is explicit (e.g., named arguments, flags, table columns).
Challenge:: Inferring Nu's explicit structure from POSIX's implicit one.

=== Command vs. Expression:

POSIX:: Almost everything is a command.
Nu:: Distinguishes between commands (which operate on data) and expressions (which evaluate to data).
Challenge:: Deciding when a POSIX command maps to a Nu command and when it maps to an expression (e.g., echo "hello" might be echo "hello" or "hello" piped to a command that prints).

=== Feature Discrepancies:

Nu-specific features:: Custom commands, record/table literals, advanced data manipulation commands (e.g., group-by, pivot).
These have no direct POSIX equivalent.
POSIX-specific features:: Complex parameter expansions, arithmetic expansion, specific redirection types (e.g., exec for file descriptor manipulation).
These might require complex Nu equivalents or be untranslatable.

== Proposed Mapping Strategy (High-Level)

A mapping strategy would involve a recursive traversal of the POSIX AST, transforming each node into its Nu equivalent.

=== Direct Equivalents
Some constructs have relatively direct mappings:
* Simple Command:
  * POSIX CommandNode(name, args) rightarrow Nu Call(name, args).
  * Challenge: Arguments might need type inference or explicit casting in Nu. E.g.,
    ls -l is straightforward, but grep "pattern" file might imply open file | lines | where ....
* Pipeline:
  * POSIX PipelineNode(cmd1, cmd2, ...) rightarrow Nu Pipeline(cmd1_nu, cmd2_nu, ...).
  * Challenge: The data flow changes from text to structured. cat file | grep pattern in POSIX might become open file | lines | where ($it =~ "pattern") in Nu.
* Variable Assignment:
  * POSIX AssignmentNode(name, value) rightarrow Nu LetNode(name, value_expr).
  * Challenge: POSIX variables are always strings. Nu variables can be any type. FOO=123 might become let foo = 123 (integer) or let foo = "123" (string) depending on context.

=== Structural Transformations
* Redirections:
  * POSIX Command > file rightarrow Nu Command | save file.
  * POSIX Command < file rightarrow Nu open file | Command.
  * Challenge: Standard error redirection (2> file) and complex file descriptor manipulations (exec 3<> file) are harder.
    Nu might require stderr_to_string or wrap commands,
    or might not have direct equivalents for all exec functionalities.
* Conditional Statements (if):
  * POSIX IfNode(condition, then_block, else_block) rightarrow Nu IfNode(condition_expr, then_block_nu, else_block_nu).
  * Challenge: POSIX conditions are based on command exit codes.
    Nu conditions are boolean expressions.
    if grep -q "pattern" file; then ... needs to be translated to if ((open file | lines | any ($it =~ "pattern"))) { ... }.
* Loops (for, while):
  * POSIX ForNode(var, list, body) rightarrow Nu ForNode(var, list_expr, body_nu).
  * POSIX WhileNode(condition, body) rightarrow Nu LoopNode(WhileCondition(condition_expr), body_nu).
  * Challenge: Similar to if conditions, POSIX loop conditions are command-based.

=== Semantic Translations

* Command Substitution:
  * POSIX $(command) rightarrow Nu (command_nu).
  * Challenge: The output of the inner command in POSIX is a string. In Nu, it's structured data. If $(ls) is used to get a list of filenames, Nu's (ls) would return a table of file metadata, requiring further processing (e.g., (ls | get name) or (ls | str join " ")).
* Arithmetic Expansion:
  * POSIX $((expression)) rightarrow Nu (expression_nu).
  * Challenge: Nu's arithmetic is more type-aware. $((1 + 2)) maps directly to (1 + 2).
* Parameter Expansion:
  * POSIX ${VAR} rightarrow Nu $VAR.
  * POSIX ${VAR:-default} rightarrow Nu $VAR? ?? default_value.
  * Challenge: Some complex POSIX parameter expansions (e.g., string manipulation like ${VAR#prefix}) might require explicit Nu string commands (str starts-with, str substring, etc.).

=== Handling Differences and Nu-Specifics

==== Nu's Structured Data:
When a POSIX command's output is consumed by another,
the mapping needs to decide how to represent that text stream as Nu structured data.
This might involve:

* lines: For line-by-line processing.
* from csv, from json, from yaml: If the text stream is known to be structured data.
* split row: To break a string into a list of strings.
* parse: To apply a pattern to extract data.
* This is the most complex part of the mapping.

==== Nu's Blocks and Closures:
POSIX functions map well to Nu custom commands (def).
Anonymous blocks in Nu are more flexible than POSIX subshells.

==== Error Handling:
POSIX relies on exit codes.
Nu uses try/catch blocks and propagates errors.
Mapping set -e or errexit behavior from POSIX would require careful consideration of Nu's error handling.

== Example Conceptual Mappings

Let's illustrate with a few conceptual examples:

Example 1: Simple CommandPOSIX AST (conceptual):
[source,ast]
----
CommandNode {
    name: "ls",
    arguments: ["-l", "/path/to/dir"]
}
----
Nu AST (conceptual):
[source,ast]
----
Call {
    head: "ls",
    arguments: [
        Flag { name: "l" },
        Literal { type: "path", value: "/path/to/dir" }
    ]
}
----
Example 2: PipelinePOSIX AST (conceptual)
[source,ast]
----
PipelineNode {
    commands: [
        CommandNode { name: "cat", arguments: ["file.txt"] },
        CommandNode { name: "grep", arguments: ["pattern"] }
    ]
}
----
Nu AST (conceptual):
[source,ast]
----
Pipeline {
    elements: [
        Call { head: "open", arguments: [Literal { type: "path", value: "file.txt" }] },
        Call { head: "lines" }, // Convert text to lines
        Call {
            head: "where",
            arguments: [
                Block {
                    statements: [
                        BinaryOp {
                            operator: "=~",
                            left: Variable { name: "$it" },
                            right: Literal { type: "string", value: "pattern" }
                        }
                    ]
                }
            ]
        }
    ]
}
----
Example 3: Conditional StatementPOSIX AST (conceptual):
[source,ast]
----
IfNode {
    condition: CommandNode { name: "test", arguments: ["-f", "file.txt"] },
    then_branch: BlockNode {
        commands: [ CommandNode { name: "echo", arguments: ["File exists"] } ]
    },
    else_branch: null
}
Nu AST (conceptual):IfNode {
    condition: Call {
        head: "path",
        arguments: [Literal { type: "string", value: "file.txt" }],
        flags: [Flag { name: "exists" }]
    },
    then_branch: Block {
        statements: [ Call { head: "print", arguments: [Literal { type: "string", value: "File exists" }] } ]
    },
    else_branch: null
}
----
(Note: test -f maps to path exists or path type == file in Nu)

== Conclusion

Creating a robust mapping between the yash-syntax POSIX AST and the Nushell AST is a significant undertaking.
It requires a deep understanding of both shell grammars, their underlying execution models,
and their respective philosophies regarding data handling.
The most challenging aspects involve transforming POSIX's string-based data flow into Nu's structured data flow and
handling the semantic differences in control flow conditions and variable expansions.
Such a mapping would likely involve a set of transformation rules,
potentially with heuristics or user-defined mappings for ambiguous cases,
to bridge the gap between these two distinct shell paradigms.
